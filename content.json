{"meta":{"title":"iAds | 在这里，总有你想要的～","subtitle":"在这里，总有你想要的～","description":"在这里，有学习和分享；在这里，总有你想要的～","author":"ArvinLiang","url":"https://olddaddy0.github.io"},"posts":[{"title":"程序化广告术语脑图","slug":"ad-words","date":"2021-07-12T16:00:00.000Z","updated":"2023-08-03T12:46:23.244Z","comments":true,"path":"2021/07/13/ad-words/","link":"","permalink":"https://olddaddy0.github.io/2021/07/13/ad-words/","excerpt":"","text":"","raw":null,"content":null,"categories":[],"tags":[{"name":"程序化广告","slug":"程序化广告","permalink":"https://olddaddy0.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%8C%96%E5%B9%BF%E5%91%8A/"},{"name":"术语解析","slug":"术语解析","permalink":"https://olddaddy0.github.io/tags/%E6%9C%AF%E8%AF%AD%E8%A7%A3%E6%9E%90/"}]},{"title":"ad-mediation-reference","slug":"ad-mediation-reference","date":"2021-04-16T16:49:22.000Z","updated":"2023-08-03T12:46:23.244Z","comments":true,"path":"2021/04/17/ad-mediation-reference/","link":"","permalink":"https://olddaddy0.github.io/2021/04/17/ad-mediation-reference/","excerpt":"","text":"定义业内聚合（Admob）应用内竞价应用内竞价是一种先进的程序化广告竞价技术，它允许多个广告源对您的广告库存进行同时竞价，最高出价者赢得该次广告展示机会。 应用内竞价带来的更多可能","raw":null,"content":null,"categories":[],"tags":[{"name":"程序化广告","slug":"程序化广告","permalink":"https://olddaddy0.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%8C%96%E5%B9%BF%E5%91%8A/"},{"name":"术语解析","slug":"术语解析","permalink":"https://olddaddy0.github.io/tags/%E6%9C%AF%E8%AF%AD%E8%A7%A3%E6%9E%90/"}]},{"title":"【每日广告】CPM vs. eCPM","slug":"daily-cpm-vs-ecpm-reference","date":"2020-12-31T16:00:00.000Z","updated":"2023-08-03T12:46:23.245Z","comments":true,"path":"2021/01/01/daily-cpm-vs-ecpm-reference/","link":"","permalink":"https://olddaddy0.github.io/2021/01/01/daily-cpm-vs-ecpm-reference/","excerpt":"","text":"🌟【每日广告】系列- 为什么有这个系列？(WHY)许多人对于互联网广告行业很有兴趣，但不知道怎么入行或如何系统学习？通过每天了解一些广告领域的知识，有助于积累知识的广度和深度。 这个系列是什么？(WHAT) 常用名词解释，带你快速理解和认识名词的含义和背后的技术； 文章分享，每日挑选一篇互联网文章进行重点摘要，并分享可能的思考方向； 谁适合阅读这个系列？(WHO)想快速了解互联网广告行业知识，学习互联网商业变现的人。 CPM是什么？CPM全称为Cost Per Mille或者是Cost Per ThousandImpression, 也称千人展示成本。 CPM 是一种计价的指标。 CPM是一种展示付费广告，只要展示了广告主的广告内容，广告主就为此付费。这种广告的效果不是很好，但是却能给有一定流量的网站、博客带来稳定的收入。 eCMP是什么？eCPM（effective cost per mille）指的就是每一千次展示可以获得的广告收入，展示的单位可以是网页，广告单元，甚至是单个广告（在 AdSense “高级报告”的“数据展示依据”下拉框中可以选择）。默认情况下，eCPM 指的都是千次网页展示（Pageview）收入。eCPM 只是用来反映网站盈利能力的参数，不代表收入。 eCPM是衡量广告效果的指标 eCPM公式 eCPM &#x3D; （广告总费用 &#x2F; 测得的广告展示量总数） x 1,000 参考链接 Techwalla - ECPM vs. CPM 广告投放计费方式中，CPM和eCPM的区别是什么?","raw":null,"content":null,"categories":[],"tags":[{"name":"程序化广告","slug":"程序化广告","permalink":"https://olddaddy0.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%8C%96%E5%B9%BF%E5%91%8A/"},{"name":"术语解析","slug":"术语解析","permalink":"https://olddaddy0.github.io/tags/%E6%9C%AF%E8%AF%AD%E8%A7%A3%E6%9E%90/"},{"name":"每日广告","slug":"每日广告","permalink":"https://olddaddy0.github.io/tags/%E6%AF%8F%E6%97%A5%E5%B9%BF%E5%91%8A/"}]},{"title":"自适应锚定横幅广告 （Upgrade your banner ads with new adaptive anchor banners）","slug":"upgrade-your-banner-ads-with-new-adaptive-anchor-banners","date":"2019-12-01T16:00:00.000Z","updated":"2023-08-03T12:46:23.245Z","comments":true,"path":"2019/12/02/upgrade-your-banner-ads-with-new-adaptive-anchor-banners/","link":"","permalink":"https://olddaddy0.github.io/2019/12/02/upgrade-your-banner-ads-with-new-adaptive-anchor-banners/","excerpt":"","text":"原文：Upgrade your banner ads with new adaptive anchor banners 现在的移动设备类型各种各样，屏幕尺寸更是层出不穷（UI布局适配问题已经不再只是Android同学头痛的事情了）。横幅广告为了更充分的适配不同宽高比的设备，Google Admob SDK创建了一个新的横幅广告类型：adaptive anchor banners。 自适应横幅广告的优势 Adaptive anchor banners are designed to be a drop-in replacement for the industry standard 320x50 banner size and the smart banner format. 自适应横幅广告旨在暂时取代符合行业标准的 320x50 横幅广告尺寸及智能横幅广告格式。 标准的 320x50 横幅广告，在不同分辨率的设备上，展示效果不可控，不是太小就是太大。而智能横幅广告格式仅支持固定高度，因此通常返回的广告素材在高分辨率设备上看起来太小。 Adaptive anchor banners return creatives with the best height and aspect ratio for each device, with hard limits to prevent the wrong sizes from being served. 自适应横幅广告是一种更好的选择，原因如下： 这种广告采用提供的宽度（而非全屏宽度），这样您就可以将安全区域考虑在内。 它会为特定设备选择最优高度，而非针对不同尺寸的设备均使用固定高度，从而降低了设备屏幕尺寸造成的影响。 Standard banner vs. smart banner vs. AdMob’s adaptive anchor banner 快速入门 Adaptive anchor banners are currently only available for anchored placements—banners locked to the top or bottom of the screen. 这种横幅广告的尺寸通常用于锚定横幅广告（通常被锁定在屏幕的顶部或底部）。 要植入简单的自适应锚定横幅广告，请按照以下步骤操作： 创建一个GADBannerView对象并设置广告单元 ID。 获取自适应横幅广告尺寸。 您获取的尺寸将用于请求自适应横幅广告。要获取自适应广告尺寸，请务必执行以下操作： 获取所用设备的宽度，或者自行设置宽度（如果您不想使用屏幕的全宽）。 针对广告尺寸类使用相应的静态方法（例如GADCurrentOrientationAnchoredAdaptiveBannerAdSizeWithWidth(CGFloat width)），以获取所选屏幕方向的自适应GADAdSize对象。 针对横幅广告视图设置广告尺寸，具体做法是，在GADBannerView上设置 adSize 属性。 在预先准备的广告视图中使用loadRequest方法创建广告请求对象并加载横幅广告，其处理方式与常规横幅广告请求一样。","raw":null,"content":null,"categories":[],"tags":[{"name":"GoogleAds","slug":"GoogleAds","permalink":"https://olddaddy0.github.io/tags/GoogleAds/"},{"name":"广告","slug":"广告","permalink":"https://olddaddy0.github.io/tags/%E5%B9%BF%E5%91%8A/"}]},{"title":"让视频广告体验更加友好的五种方法","slug":"five-ways-to-make-your-app-video-ad-friendly","date":"2019-11-29T03:28:31.000Z","updated":"2023-08-03T12:46:23.245Z","comments":true,"path":"2019/11/29/five-ways-to-make-your-app-video-ad-friendly/","link":"","permalink":"https://olddaddy0.github.io/2019/11/29/five-ways-to-make-your-app-video-ad-friendly/","excerpt":"","text":"原文：Five ways to make your app video-ad friendly 允许视频数据预拉取缓存（Load ads well in advance to permit buffering） The moment you load a video ad, behind the scenes the ad starts buffering (essentially pre-loading) the video 开始加载一个视频广告，仅仅是视频资源开始启动资源加载和缓存，所以the network is the bottleneck。在用户无感知的前提下，触发加载视频广告，在一定的缓存数据量后再展示广告，用户体验更好 Load your ad at least 15 seconds in advance of showing it 对于广告加载的超时时长或者提前预拉的时间间隔可做参考 及时释放无效广告（Free unused ads） 场景例子：加载了激励视频广告，但用户拒绝了观看，及时释放该广告。（内存、视频解码器…) On Android, we recommend you null your reference to the ad, and if you’re using native ads, call UnifiedNativeAd.destroy() on the main thread. On iOS, set your reference to nil. Android 推荐将广告引用置空，如果是调用原生广告，需要在住线程调用UnifiedNativeAd.destroy()；iOS则是将引用置 nil。 避免加载多个广告（Avoid loading multiple concurrent ads） Every phone has a limit to the number of videos it can hold in a prepared state. 在这个大前提下，仅加载你需要的广告，以获得最好的成功曝光体验。 在广告loaded回调后再展示广告（Don’t show an ad before receiving a notification that it has loaded） GMA SDK通过通知notifications同步视频广告的加载及播放状态。 On Android, this notification arrives through AdListener.onAdLoaded(). 在播放视频广告前释放应用自身的视频资源（Be extra cautious combining video ads with video content） 内存中避免同时加载着多个视频资源（不管都是视频广告还是应用内的视频内容）。","raw":null,"content":null,"categories":[],"tags":[{"name":"GoogleAds","slug":"GoogleAds","permalink":"https://olddaddy0.github.io/tags/GoogleAds/"},{"name":"广告","slug":"广告","permalink":"https://olddaddy0.github.io/tags/%E5%B9%BF%E5%91%8A/"}]},{"title":"创建私有库的一些小技巧","slug":"skills-for-private-pod-repo","date":"2019-10-01T16:00:00.000Z","updated":"2023-08-03T12:46:23.245Z","comments":true,"path":"2019/10/02/skills-for-private-pod-repo/","link":"","permalink":"https://olddaddy0.github.io/2019/10/02/skills-for-private-pod-repo/","excerpt":"","text":"简介创建private pods流程 使用说明环境要求 需要安装Cocapods Git仓库要求: 需要对应的repo的master读写权限。 创建步骤 将管理podspec文件的repo放入到本地的cocoapods repo文件夹中 12345$ pod repo add REPO_NAME SOURCE_URL REPO_NAME: oa-ibg-tech-podspecs SOURCE_URL: git@git.code.oa.com:IBG-TECH/PodSpecs.git直接复制以下代码运行即可:$ pod repo add oa-ibg-tech-podspecs git@git.code.oa.com:IBG-TECH/PodSpecs.git 添加完之后如果成功 repo会存入以下文件夹 1~/.cocoapods/repos/REPO_NAME 注意事项： REPO_NAME 为本地的repo名称 可以先到目录~/.cocoapods/repos/确认repo是否已经添加到本地 SOURCE_URL 服务端的repo URL （ssh https任选） 为目标工程branch添加tag 在本地的git 目录下打开terminal 注意事项： 该目录为组件工程的目录 不是pods add的目录 tag必须添加 否者无法找到对应的工程branch 12$ git tag TAG_VERSION$ git push --tag 创建Podspec文件 Podspec Basic Reference 12345678910111213141516171819202122232425262728293031Pod::Spec.new do |s|s.name = &quot;DebugOptions&quot;s.version = &quot;0.0.1&quot;s.summary = &quot;小组件&quot; s.description = &lt;&lt;-DESC一个便捷的小组件。DESC s.homepage = &quot;http://github.com/DebugOptions&quot; s.license = &#123; :type =&gt; &#x27;Copyright&#x27;, :text =&gt; &lt;&lt;-LICENSE © 1998-2019 Company. All rights reserved. LICENSE&#125; s.author = &#123; &quot;holaween&quot; =&gt; &quot;lianghwen@live.cn&quot; &#125;s.social_media_url = &quot;http://twitter.com/haowenliang&quot; s.platform = :ios, &quot;9.0&quot;s.source = &#123; :git =&gt; &quot;http://github.com/DebugOptions.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125; s.source_files = &quot;Classes&quot;, &quot;DebugOptions/**/*.&#123;h,m,mm&#125;&quot;s.public_header_files = &quot;DebugOptions/**/*.h&quot; s.requires_arc = true end 以上为Podspec模版 如果用pod spec create生成 需要手动修改以上内容 注意事项： tag为刚才git中标记的branch tag tag命名规范参考 对于包涵图片，本地化strings文件的pod，将该类资源文件做成bundle 本地化strings文件必须在bundle里面才能起作用 调用方法 123NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;Bundle_Name&quot; ofType:@&quot;bundle&quot;];NSBundle *bundle = [NSBundle bundleWithPath:path];[bundle localizedStringForKey:@&quot;String_Key&quot; value:@&quot;default value&quot; table:@&quot;Table_Name&quot;]; 上传PodSpec文件 pod repo push REPO_NAME .podspec文件目录 该步骤会检测对应的pod目录是否validate 验证通过后 会将PodSpec文件上传到同名的文件夹中 结构如下: ├── PodSpecs └── [SPEC_NAME] └── [VERSION] └── [SPEC_NAME].podspec 关于如何规避validate过程产生的问题，见 Podspec Basic Reference&#x2F;格式检查 （非常重要） 项目导入pod 1234567891011# Uncomment this line to define a global platform for your projectplatform :ios, &#x27;9.0&#x27; source &#x27;官方podspec文件的URL&#x27;source &#x27;podspec文件的SOURCE_URL&#x27;target &#x27;PROJECT_NAME&#x27; do pod &#x27;SPEC_NAME&#x27;, &#x27;~&gt; VERSION&#x27;end 注意：source的url应为https 误操作的移除／修改 上传之前应当检查确保无误 如果不是必要状况 不要轻易删除 123pod trunk delete PODNAME VERSION pod trunk deprecate PODNAME","raw":null,"content":null,"categories":[],"tags":[{"name":"Skill","slug":"Skill","permalink":"https://olddaddy0.github.io/tags/Skill/"},{"name":"iOS","slug":"iOS","permalink":"https://olddaddy0.github.io/tags/iOS/"}]},{"title":"如何快速创建Podspec文件","slug":"quick-start-podspec","date":"2019-09-30T16:00:00.000Z","updated":"2023-08-03T12:46:23.245Z","comments":true,"path":"2019/10/01/quick-start-podspec/","link":"","permalink":"https://olddaddy0.github.io/2019/10/01/quick-start-podspec/","excerpt":"","text":"简介 私有库创建时对应项目的podspec文件书写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139## Be sure to run `pod spec lint new.podspec&#x27; to ensure this is a# valid spec and to remove all comments including this before submitting the spec.## To learn more about Podspec attributes see https://docs.cocoapods.org/specification.html# To see working Podspecs in the CocoaPods repo see https://github.com/CocoaPods/Specs/#Pod::Spec.new do |spec| # ――― Spec Metadata ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # # These will help people to find your library, and whilst it # can feel like a chore to fill in it&#x27;s definitely to your advantage. The # summary should be tweet-length, and the description more in depth. # spec.name = &quot;new&quot; spec.version = &quot;0.0.1&quot; spec.summary = &quot;A short description of new.&quot; # This description is used to generate tags and improve search results. # * Think: What does it do? Why did you write it? What is the focus? # * Try to keep it short, snappy and to the point. # * Write the description between the DESC delimiters below. # * Finally, don&#x27;t worry about the indent, CocoaPods strips it! spec.description = &lt;&lt;-DESC DESC spec.homepage = &quot;http://EXAMPLE/new&quot; # spec.screenshots = &quot;www.example.com/screenshots_1.gif&quot;, &quot;www.example.com/screenshots_2.gif&quot; # ――― Spec License ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # # Licensing your code is important. See https://choosealicense.com for more info. # CocoaPods will detect a license file if there is a named LICENSE* # Popular ones are &#x27;MIT&#x27;, &#x27;BSD&#x27; and &#x27;Apache License, Version 2.0&#x27;. # spec.license = &quot;MIT (example)&quot; # spec.license = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;FILE_LICENSE&quot; &#125; # ――― Author Metadata ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # # Specify the authors of the library, with email addresses. Email addresses # of the authors are extracted from the SCM log. E.g. $ git log. CocoaPods also # accepts just a name if you&#x27;d rather not provide an email address. # # Specify a social_media_url where others can refer to, for example a twitter # profile URL. # spec.author = &#123; &quot;Holaween&quot; =&gt; &quot;lianghwen@live.cn&quot; &#125; # Or just: spec.author = &quot;Holaween&quot; # spec.authors = &#123; &quot;Holaween&quot; =&gt; &quot;lianghwen@live.cn&quot; &#125; # spec.social_media_url = &quot;https://twitter.com/Holaween&quot; # ――― Platform Specifics ――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # # If this Pod runs only on iOS or OS X, then specify the platform and # the deployment target. You can optionally include the target after the platform. # # spec.platform = :ios # spec.platform = :ios, &quot;5.0&quot; # When using multiple platforms # spec.ios.deployment_target = &quot;5.0&quot; # spec.osx.deployment_target = &quot;10.7&quot; # spec.watchos.deployment_target = &quot;2.0&quot; # spec.tvos.deployment_target = &quot;9.0&quot; # ――― Source Location ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # # Specify the location from where the source should be retrieved. # Supports git, hg, bzr, svn and HTTP. # spec.source = &#123; :git =&gt; &quot;http://EXAMPLE/new.git&quot;, :tag =&gt; &quot;#&#123;spec.version&#125;&quot; &#125; # ――― Source Code ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # # CocoaPods is smart about how it includes source code. For source files # giving a folder will include any swift, h, m, mm, c &amp; cpp files. # For header files it will include any header in the folder. # Not including the public_header_files will make all headers public. # spec.source_files = &quot;Classes&quot;, &quot;Classes/**/*.&#123;h,m&#125;&quot; spec.exclude_files = &quot;Classes/Exclude&quot; # spec.public_header_files = &quot;Classes/**/*.h&quot; # ――― Resources ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # # A list of resources included with the Pod. These are copied into the # target bundle with a build phase script. Anything else will be cleaned. # You can preserve files from being cleaned, please don&#x27;t preserve # non-essential files like tests, examples and documentation. # # spec.resource = &quot;icon.png&quot; # spec.resources = &quot;Resources/*.png&quot; # spec.preserve_paths = &quot;FilesToSave&quot;, &quot;MoreFilesToSave&quot; # ――― Project Linking ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # # Link your library with frameworks, or libraries. Libraries do not include # the lib prefix of their name. # # spec.framework = &quot;SomeFramework&quot; # spec.frameworks = &quot;SomeFramework&quot;, &quot;AnotherFramework&quot; # spec.library = &quot;iconv&quot; # spec.libraries = &quot;iconv&quot;, &quot;xml2&quot; # ――― Project Settings ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # # # If your library depends on compiler flags you can set them in the xcconfig hash # where they will only apply to your library. If you depend on other Podspecs # you can include multiple dependencies to ensure it works. # spec.requires_arc = true # spec.xcconfig = &#123; &quot;HEADER_SEARCH_PATHS&quot; =&gt; &quot;$(SDKROOT)/usr/include/libxml2&quot; &#125; # spec.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot;end 以上为标准生成的podspec文件结构，生成代码为 12pod spec create PODSPEC_NAME 结构说明Spec Metadata 私有库基本描述内容，以下为必要内容 name 私有库名称 必须和文件名称相同 version 版本 对应git项目中的tag summary 总结 description 详细描述 必须长于总结 homepage 主页 用git上的页面即可 Spec License license 证书 123456s.license = &#123; :type =&gt; &#x27;Copyright&#x27;, :text =&gt; &lt;&lt;-LICENSE © 1990-2019 Company. All rights reserved. LICENSE &#125; Author Metadata authors 作者 12spec.authors = &#123;&#x27;Darth Vader&#x27; =&gt; &#x27;darthvader@darkside.com&#x27;, &#x27;Wookiee&#x27; =&gt; &#x27;wookiee@aggrrttaaggrrt.com&#x27; &#125; Platform Specifics platform 对应平台，必须指明iOS版本 1s.platform = :ios, &quot;9.0&quot; Source Location source pod下载代码的地址 尾部tag指定为version 1s.source = &#123; :git =&gt; &quot;http://EXAMPLE/new.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125; 可以指定branch，但是不推荐。 Source Code source_files 私有库代码文件 1s.source_files = &quot;Classes/**/*.&#123;h,m,mm&#125;&quot; * 指定的文件必须为可编译的代码文件 * 注意格式： * \\**在其中代表了所有文件夹 * \\*为通配符 subspec subspec内的文件必须可以单独编译成功 1234567subspec &#x27;Twitter&#x27; do |sp| sp.source_files = &#x27;Classes/Twitter&#x27;endsubspec &#x27;Pinboard&#x27; do |sp| sp.source_files = &#x27;Classes/Pinboard&#x27;end Resources － 非必要 resources 资源文件 用于图片，声音类的资源 .h.m类文件放入资源不会被编译，指定形式与source code一样 xib，storyboard文件也可以直接作为资源文件导入，导入时注意添加UIKit.frameworks xib导入时必须以resources导入一次，然后以resources_bundle导入一次 使用时直接利用名称找到resource_bundles，然后利用bundle加载xib 1234567891011s.resources = &quot;File_Path/*.xib&quot;,&quot;File_Path/*.png&quot;s.resource_bundles = &#123;&#x27;Resources&#x27; =&gt; [&quot;File_Path/*.xib&quot;,&quot;File_Path/*.png&quot;]&#125;// 使用NSString *bundlePath = [[NSBundle mainBundle] pathForResource:@&quot;Resources&quot; ofType:@&quot;bundle&quot;];NSBundle *bundle = [NSBundle bundleWithPath:bundlePath];[[UIViewController alloc] initWithNibName:@&quot;Xib_Name&quot; bundle:bundle]; 如果需要导入本地化.strings应该放入一个bundle中来实现 123NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;Bundle_Name&quot; ofType:@&quot;bundle&quot;];NSBundle *bundle = [NSBundle bundleWithPath:path];[bundle localizedStringForKey:@&quot;Key&quot; value:@&quot;default value&quot; table:@&quot;Table_Name&quot;]; Project Linking － 非必要 frameworks libraries 用于添加系统的依赖库 12s.frameworks = &quot;SomeFramework&quot;, &quot;AnotherFramework&quot;s.libraries = &quot;iconv&quot;, &quot;xml2&quot; vendored_frameworks vendored_library 用于添加第三发依赖库 12s.vendored_frameworks = &quot;SomeFramework&quot;, &quot;AnotherFramework&quot;s.vendored_library = &quot;iconv&quot;, &quot;xml2&quot; Project Settings s.requires_arc &#x3D; true 现在这条基本必加了 xcconfig 对应项目的一些配置 1s.xcconfig = &#123; &quot;HEADER_SEARCH_PATHS&quot; =&gt; &quot;$(SDKROOT)/usr/include/libxml2&quot; &#125; dependency 其它依赖库 1s.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot; 注意： 如果为私有库需要指定好source，branch 或 tag 如果私有库的podspec文件以官方形式维护，示例方式即可 参考文档格式检查 （非常重要） 编辑完成之后 需要先检查格式无误 编译能够通过 才能上传 否者上传会失败 检查方式 1pod spec lint .PODSPEC_FILE_ADDRESS 相关参数： –verbose 查看编译的详情 以理清错误 –allow-warnings 允许编译警告 –use-libraries 通常用于避免i386 x86的编译错误 –sources&#x3D;”SOURCE_URL, SOURCE_URL” 如果包含私有库的dependency必须加入该参数","raw":null,"content":null,"categories":[],"tags":[{"name":"Skill","slug":"Skill","permalink":"https://olddaddy0.github.io/tags/Skill/"},{"name":"iOS","slug":"iOS","permalink":"https://olddaddy0.github.io/tags/iOS/"}]},{"title":"一些可能性较高的Git使用约定","slug":"some-basic-git-references","date":"2019-09-02T16:00:00.000Z","updated":"2023-08-03T12:46:23.245Z","comments":true,"path":"2019/09/03/some-basic-git-references/","link":"","permalink":"https://olddaddy0.github.io/2019/09/03/some-basic-git-references/","excerpt":"","text":"tags每个发布的版本会有 tag 跟踪。 eg.) v1.0.0 mastermaster 是最稳定的分支，随时可以当作 release 版本，只能从其他分支合入，不能在上面做任何提交；每个版本发布之后，对应的发布分支会合并到 master。只接收 release&#x2F;hotfix 分支的合并。 develop主干开发分支，是稳定的、最新的分支，主要合并其他分支，比如 feature 分支、bugfix 分支。每个版本发布的 release 分支从 develop 分支检出。对于旧版本的 bugfix，需要从 develop 检出分支，修复后合回 develop。 release每个确认要发布的版本测试稳定之后，基于 develop 检出独立的 release 分支，来确保发布流的稳定；发布之后，合到主干分支（develop 和 master），并打上 tag。每个 release 分支会保留 2 个版本。命名规则 release + 版本描述，示例 release_v1.0.0。 eg.) release/release_v1.0.0 feature（具体按功能命名）新功能（需求）的开发分支，新功能在 feature 分支开发并测试稳定之后，确认发布时，合并到develop进行进步一测试，等待发布。合并时注意，先 rebase develop 分支，然后提交合并到 develop 分支，并且要确保提交历史整洁性。 eg.) feature/moment_preview feature/bugfix_moment_preview hotfix紧急 bug 修复分支。已发布的版本，需要紧急修复 bug 重新上线，从之前 release 分支检出 hotfix 分支来修复和发布；发布之后，合到主干分支（develop 和 master），并打上 tag。命名规则 hotfix + 版本描述，示例 hotfix_v1.0.0。 eg.) release/hotfix_v1.0.1 git commitcommit 原子化 为了方便追溯，每个 commit 以尽量小的单位进行 commit，粒度要适当。 一个 commit 一个需求或功能点，一个 commit 一个 bugfix。 commit message： 对于较大内容体的提交，commit 的 message 第一行写总结性的描述，然后空一行，再对提交做详细的描述 commit 的 message 要详细的描述修改内容，对于解决的问题，需要描述原因。 参考：解决因为 xxx 而引起 xxx 的问题，优化了因为 xxx 导致的 xxx 问题；如：解决因为 xxx 而导致崩溃问题，解决因为 xxx 情况下空指针导致的崩溃问题 禁止：解决了一个崩溃问题，解决了UI不对的问题…… 需要注明改动的影响面，尤其是在bug平台上无法体现的优化。 格式：换行，[影响范围] xxxx。 commit 整合 禁止将过于零散的 commit 提交合并到主干分支：对于需求或者模块化的 commit，尤其是在协作开发时，如果 commit 过于零散的，需要整合成一个 commit，使用 git rebase -i。 commit 样板 __【标题】内容__，如“【Feature】xxxxx”。 commit 标题： 【Update】 工程配置等相关信息更新 【Optimize】 优化类的提交 【Feature】 需求方面的提交 【Bugfix】 针对 bugfree 上的 bug 修复 对于 Bug 的 commit需要体现具体的bugid或者bug链接。 commit示例【Bugfix-90011】解决480*320屏幕的机型，特效框显示不完整问题 【Feature】产品要求修改设置页检查更新new逻辑 【Optimize】优化消息收发速度，提升10%成功率 【Update】更新人脸识别静态库v1.1.0版本：优化人脸识别速度 git merge &amp; git rebasegit merge Fast-Forward 的合并才能进行直接 merge，否则必须使用 rebase，确保时间轴的单一性。 对于已经 merge 过的分支，不要使用 rebase，避免重复的 commit 节点。 git rebase 本地分支开发一段时间之后，如果要合并回主干分支，必须先 rebase 主干分支，再进行合并。 减少不必要的 commit，对于需求或者模块化的 commit，尤其是在协作开发时，如果 commit 过于零散的，需要整合成一个 commit 才能合并到主干分支；使用 git rebase -i。 Merge request 严格遵循 分支模型 提交合并请求 代码必须经过严格自测，才能提交合并到主干分支；对于新功能，必须达到一定的完成度，才能合并到主干分支。 尽早提交 merge request，避免代码堆积引起过多冲突，增加审核成本。 当存在还没有合并的 merge request，需要合并完之后，再 rebase 提交，确保时间轴的单一性。 Bugfix 阶段，merge request 中 commit 数量不能超过5个；需求阶段可灵活控制。 Bugfix 阶段，修改了 Bugfree 状态的 commit，要及时合并（当天的要在当天合并完）。 Merge request 被合并之后，及时清理无用的远程分支。 git log master、develop 等主干同步时，用__git log master..develop__，确认是否一致 技巧： git log branch1..branch2 # 显示 branch2 比 branch1 前进多少 commit","raw":null,"content":null,"categories":[],"tags":[{"name":"Skill","slug":"Skill","permalink":"https://olddaddy0.github.io/tags/Skill/"},{"name":"Git","slug":"Git","permalink":"https://olddaddy0.github.io/tags/Git/"}]},{"title":"同一设备管理多个Git帐号","slug":"one-device-support-multi-git-accounts","date":"2019-09-01T16:00:00.000Z","updated":"2023-08-03T12:46:23.245Z","comments":true,"path":"2019/09/02/one-device-support-multi-git-accounts/","link":"","permalink":"https://olddaddy0.github.io/2019/09/02/one-device-support-multi-git-accounts/","excerpt":"","text":"前言在日常开发中，我们一定会遇到使用多个Git帐号或者平台的情况。比如自己造轮子的github，干私活能有免费私有仓库gitee，工作中公司搭建的私有git平台等等。那么希望在一台设备上提交不同平台的代码，我们就一定要知道如何配置SSH Key来实现验证流程（其实也不一定，使用一些成熟的可视化代码管理工具如 source tree也是可以的）。 配置SSH Key(github为🌰)打开你的终端，到 .ssh 目录 $ cd ~&#x2F;.ssh 常规方法生成一个 SSH Key $ ssh-keygen -t rsa -C “&#x79;&#111;&#117;&#114;&#x40;&#101;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;“ 自定义生成key的名字名字定义要清晰，因为你的设备下可能会有多个rsa文件。 密码的设置看自己喜好 配置github或者其他平台复制公钥 $ pbcopy &lt; ~&#x2F;.ssh&#x2F;test_rsa.pub 到github或者其他平台的设置项中，找到SSH and GPG keys 选项执行 New SSH key的操作。 测试键入 ssh -T git@github.com，一般能够看到类似下面的输出。 $ ssh -T &#x67;&#x69;&#116;&#x40;&#x67;&#105;&#116;&#x68;&#117;&#x62;&#x2e;&#x63;&#x6f;&#x6d; Hi [UserName]! You’ve successfully authenticated, but GitHub does not provide shell access. 如果你非常不幸，没能看到这样的输出，你可以直接跳到下一环节。或者执行下面一段命令将新ssh-key添加到ssh agent中，再执行测试命令。 $ ssh-add ~&#x2F;.ssh&#x2F;test_rsa 配置多个SSH-Key为了将不同帐号的git服务器与对应的ssh-key关联，我们需要新增一个config文件。在 ~/.ssh路径下键入 $ vim config 然后键入类似下方的配置 1234567891011121314151617181920212223# company git serviceHost git.company.comHostName git.company.comPreferredAuthentications publickeyUser workerIdentityFile ~/.ssh/gitlab_rsa# cocrashHost github.comHostName github.comPreferredAuthentications publickeyUser cocrashIdentityFile ~/.ssh/cocrash_rsa# olddaddyHost olddaddy.github.comHostName github.comPreferredAuthentications publickeyUser olddaddyIdentityFile ~/.ssh/olddaddy_rsa ... ... 然后保存退出。 两个Github帐号的冲突从上面的config文件中，我们可以看到有两个HostName github.com相同的配置，但是用户不一样（你有两个Github帐号或者这台电脑两个程序员共享[奸笑]）。 验证第二个Github的帐号 $ ssh -T &#x67;&#105;&#116;&#x40;&#x6f;&#x6c;&#100;&#100;&#97;&#100;&#x64;&#121;&#x2e;&#x67;&#x69;&#x74;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#109; Hi OldDaddy0! You’ve successfully authenticated, but GitHub does not provide shell access. 所以我们通过git clone repository的时候，如果是使用 SSH 地址，则需要使用配置如下： git clone &#x67;&#x69;&#x74;&#64;&#x6f;&#x6c;&#x64;&#x64;&#97;&#x64;&#x64;&#x79;&#x2e;&#x67;&#x69;&#x74;&#x68;&#x75;&#x62;&#46;&#99;&#111;&#109;:OldDaddy0&#x2F;OldDaddy0.github.io.git –到目前为止，你可以愉快的玩耍Git了。当然，不是每一个人都能这么顺利的，总会有到各种各样的问题。对于异常情况这里不做一一介绍，欢迎一起讨论学习。","raw":null,"content":null,"categories":[],"tags":[{"name":"Skill","slug":"Skill","permalink":"https://olddaddy0.github.io/tags/Skill/"},{"name":"Git","slug":"Git","permalink":"https://olddaddy0.github.io/tags/Git/"}]},{"title":"创建Git图床","slug":"quick-start-image-repo-with-git-wiki","date":"2019-08-31T16:00:00.000Z","updated":"2023-08-03T12:46:23.245Z","comments":true,"path":"2019/09/01/quick-start-image-repo-with-git-wiki/","link":"","permalink":"https://olddaddy0.github.io/2019/09/01/quick-start-image-repo-with-git-wiki/","excerpt":"","text":"利用 github 的 wiki 来管理独立图床，而非通过创建单独的图床repo或者在当前工程repo中将图片和代码放在一起。 创建 Wiki 页面 在创建图床的项目下，点击项目的 wiki 标签 确保已经创建了 wiki 页面 Clone Wiki 从Clone this wiki locally拿到git url $ git clone https://github.com/[username]/projectname.wiki.git 存放图片到库一级目录或创建二级图片目录 建议创建一个图库的单独目录 images 上传Git管理 常见的 git 提交操作 引用图片 完整路径访问： https://raw.githubusercontent.com/wiki/[username]/[repository]/[folderifexsist]/[filename] wiki文档访问： [folderifexsist]&#x2F;[filename]","raw":null,"content":null,"categories":[],"tags":[{"name":"Skill","slug":"Skill","permalink":"https://olddaddy0.github.io/tags/Skill/"},{"name":"Git","slug":"Git","permalink":"https://olddaddy0.github.io/tags/Git/"}]},{"title":"隐私政策","slug":"7e38e8dcb6d4e31a36d8cb78795190da","date":"2018-12-31T16:00:00.000Z","updated":"2023-08-03T12:46:23.244Z","comments":false,"path":"2019/01/01/7e38e8dcb6d4e31a36d8cb78795190da/","link":"","permalink":"https://olddaddy0.github.io/2019/01/01/7e38e8dcb6d4e31a36d8cb78795190da/","excerpt":"","text":"隐私政策我们应用尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，我们会按照本隐私权政策的规定使用和披露您的个人信息。但我们将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，我们不会将这些信息对外披露或向第三方提供。我们会不时更新本隐私权政策。 您在同意我们的服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于我们应用服务使用协议不可分割的一部分。 1. 适用范围 在您使用我们应用的网络服务，或访问我们应用平台网页时，我们将自动接收并记录的您的浏览器和计算机上的信息，包括但不限于您的IP地址、浏览器的类型、使用的语言、访问日期和时间、软硬件特征信息及您需求的网页记录等数据； 我们的应用通过合法途径从商业伙伴处取得的用户个人数据。 您了解并同意，以下信息不适用本隐私权政策： 我们应用收集到的您在应用中发布的有关信息数据，包括但不限于参与活动、成交信息及评价详情； 违反法律规定或违反应用使用规则行为及我们已对您采取的措施。 2. 信息使用 我们不会向任何无关第三方提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和我们（含我们关联公司）单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些资料。 我们亦不允许任何第三方以任何手段收集、编辑、出售或者无偿传播您的个人信息。我们任何应用上平台用户如从事上述活动，一经发现，我们有权立即终止与该用户的服务协议。 为服务用户的目的，我们可能通过使用您的个人信息，向您提供您感兴趣的信息，包括但不限于向您发出产品和服务信息，或者与应用合作伙伴共享信息以便他们向您发送有关其产品和服务的信息（后者需要您的事先同意）。 3. 信息披露在如下情况下，我们将依据您的个人意愿或法律的规定全部或部分的披露您的个人信息： 经您事先同意，向第三方披露； 为提供您所要求的产品和服务，而必须和第三方分享您的个人信息； 根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露； 如您出现违反中国有关法律、法规或者应用服务协议或相关规则的情况，需要向第三方披露； 如您是适格的知识产权投诉人并已提起投诉，应被投诉人要求，向被投诉人披露，以便双方处理可能的权利纠纷； 在我们应用平台上创建的某一交易中，如交易任何一方履行或部分履行了交易义务并提出信息披露请求的，我们有权决定向该用户提供其交易对方的联络方式等必要信息，以促成交易的完成或纠纷的解决。 其它我们根据法律、法规或者网站政策认为合适的披露。 4. 信息存储和交换我们应用收集的有关您的信息和资料将保存在本应用及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或应用收集信息和资料所在地的境外并在境外被访问、存储和展示。 5. Cookie的使用 在您未拒绝接受cookies的情况下，我们会在您的计算机上设定或取用cookies，以便您能登录或使用依赖于cookies的应用平台服务或功能。我们使用cookies可为您提供更加周到的个性化服务，包括推广服务。 您有权选择接受或拒绝接受cookies。您可以通过修改浏览器设置的方式拒绝接受cookies。但如果您选择拒绝接受cookies，则您可能无法登录或使用依赖于cookies的应用网络服务或功能。 通过我们应用所设cookies所取得的有关信息，将适用本政策。 6. 信息安全 我们的帐号均有安全保护功能，请妥善保管您的用户名及密码信息。我们将通过对用户密码进行加密等安全措施确保您的信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您注意在信息网络上不存在“完善的安全措施”。 在使用我们应用的网络服务进行网上交易时，您不可避免的要向交易对方或潜在的交易对方披露自己的个人信息，如联络方式或者邮政地址。请您妥善保护自己的个人信息，仅在必要的情形下向他人提供。 7. 遵守法律您同意遵守中华人民共和国相关法律法规的所有规定，并对以任何方式使用您的密码和您的账号使用本服务的任何行为及其结果承担全部责任。如您的行为违反国家法律和法规的任何规定，有可能构成犯罪的，将被追究刑事责任，并由您承担全部法律责任。如果我们有理由认为您的任何行为，包括但不限于您的任何言论和其它行为违反或可能违反国家法律和法规的任何规定，我们可在任何时候不经任何事先通知终止向您提供服务。 8. 本隐私权政策如何更新我们可能适时会对本隐私权政策进行调整或变更，本隐私权政策的任何更新将以标注更新时间的方式公布在我们网站上，除法律法规或监管规定另有强制性规定外，经调整或变更的内容一经通知或公布后的7日后生效。如您在隐私权政策调整或变更后继续使用我们提供的任一服务或访问我们相关网站的，我们相信这代表您已充分阅读、理解并接受修改后的隐私权政策并受其约束。 9. 如何联系我们如果您对本隐私政策有任何疑问、意见或建议，通过以下方式与我们联系： 邮箱：&#x6c;&#105;&#x61;&#110;&#x67;&#x68;&#119;&#101;&#110;&#x40;&#x6c;&#105;&#118;&#101;&#46;&#x63;&#x6e;","raw":null,"content":null,"categories":[],"tags":[{"name":"App","slug":"App","permalink":"https://olddaddy0.github.io/tags/App/"}]},{"title":"Technical Support","slug":"9ef0e2e0a718dddb7eb169268ecf2153","date":"2018-12-31T16:00:00.000Z","updated":"2023-08-03T12:46:23.244Z","comments":false,"path":"2019/01/01/9ef0e2e0a718dddb7eb169268ecf2153/","link":"","permalink":"https://olddaddy0.github.io/2019/01/01/9ef0e2e0a718dddb7eb169268ecf2153/","excerpt":"","text":"App Technical Support Email：&#x6c;&#x69;&#97;&#x6e;&#103;&#x68;&#119;&#101;&#x6e;&#x40;&#x6c;&#105;&#x76;&#101;&#x2e;&#x63;&#110; TEl: +86 15013836826 © Haowen Liang","raw":null,"content":null,"categories":[],"tags":[{"name":"App","slug":"App","permalink":"https://olddaddy0.github.io/tags/App/"}]}]}